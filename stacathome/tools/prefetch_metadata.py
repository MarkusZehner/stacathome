"""
This command line tool can be used to prefetch metadata from a Provider and store it as
MetadataCollection objects in python files. These can then be augmented by hand to include
missing values or correct erroneous values.
"""

import argparse
import pathlib
import time
from datetime import date

import ufmt

import stacathome


METADATA_PY_TEMPLATE = '''
"""
This file has been automatically generated by prefetch_metadata.py

 * Creation Date:      {creation_date}
 * Provider:           {provider}
 * Collection:         {collection}
 * Manually modified:  No
"""

from datetime import date

from stacathome.metadata import Variable, CollectionMetadata, register_static_metadata

__all__ = [
    'creation_date',
    'provider',
    'collection',
    'metadata',
]

creation_date = date.fromisoformat('{creation_date}')
provider = '{provider}'
collection = '{collection}'

metadata = {metadata}

register_static_metadata(provider, collection, metadata)
'''


INIT_PY_TEMPLATE = '''
"""
This file has been automatically generated by prefetch_metadata.py

 * Creation Date:      {creation_date}
 * Manually modified:  No
"""

# Import individual modules to register their metadata:

from . import (  # noqa: F401
    {import_statements}
)

'''


def sanitize_collection_name(collection: str):
    module = 'MD_' + collection.replace('-', '_')  # the prefix is necessary for collections starting with an number
    return module


def get_filename(collection: str):
    return sanitize_collection_name(collection) + '.py'


def get_metadata_py_file(provider: str, collection: str, metadata):
    content = METADATA_PY_TEMPLATE.format(
        creation_date=date.today(),
        provider=provider,
        collection=collection,
        metadata=metadata,
    )
    return content


def get_init_py_file(collections: list[str]):
    import_statements = [f'{sanitize_collection_name(col)},' for col in collections]
    content = INIT_PY_TEMPLATE.format(creation_date=date.today(), import_statements='\n'.join(import_statements))
    return content


def write_py_file(path, content, overwrite=False):
    if path.exists() and not overwrite:
        raise ValueError(f"File '{path}' exists already. Invoke with '--overwrite' to write anyways.")

    with open(path, mode='w') as f:
        bytes_written = f.write(content)

    print(f'Wrote {bytes_written} bytes to {path}', flush=True)
    ufmt.ufmt_file(path)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--provider', '-p', required=True, help='The provider to fetch metadata from')
    parser.add_argument(
        '--collections', '-c', nargs='*', help='Which collections to fetch metadata from. (Default: fetch from all)'
    )
    parser.add_argument('--outdir', '-o', required=True, help='Where to store the resulting python files')
    parser.add_argument('--dry', '-d', action='store_true', help='If set, do not write files but just print to stdout')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing files')
    parser.add_argument('--generate-init', action='store_true', help='If set, also generates a __init__.py file')
    args = parser.parse_args()

    outdir = pathlib.Path(args.outdir).resolve()
    if not outdir.exists() or not outdir.is_dir():
        raise ValueError(f"Path '{outdir}' does not exist or is not a directory")

    provider = stacathome.get_provider(args.provider)

    if args.collections:
        collections = args.collections
    else:
        collections = provider.available_collections()

    print(f'Fetching metadata for {len(collections)} collections:\n -' + '\n - '.join(collections), flush=True)

    skipped_collections = []

    for collection in collections:
        metadata = provider.get_metadata(collection)
        if metadata is None:
            skipped_collections.append(collection)
            continue

        path = outdir / get_filename(collection)
        metadata_file = get_metadata_py_file(args.provider, collection, metadata)
        if args.dry:
            print('\n' + '-' * 120)
            print(f'File: {path}')
            print('-' * 120)
            print(metadata_file, flush=True)
        else:
            write_py_file(path, metadata_file, args.overwrite)

        time.sleep(1)

    if skipped_collections:
        print(
            f'Skipped {len(skipped_collections)} because they did not provide metadata:\n -'
            + '\n - '.join(skipped_collections),
            flush=True,
        )

    if args.generate_init:
        init_file = get_init_py_file([col for col in collections if col not in skipped_collections])
        write_py_file(outdir / '__init__.py', init_file, args.overwrite)


if __name__ == '__main__':
    main()
